name: Bump version on push

on:
  push:
    branches:
      - main  # oder dein gewünschter Branch

jobs:
  bump-version:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v3

      - name: Stop if last commit is from GitHub Actions (avoid infinite loop)
        run: |
          LAST_COMMIT_AUTHOR="$(git log -1 --pretty=format:'%an')"
          echo "Last commit author: $LAST_COMMIT_AUTHOR"
          if [ "$LAST_COMMIT_AUTHOR" = "github-actions[bot]" ]; then
            echo "Commit was made by GitHub Action, skipping..."
            exit 0
          fi

      - name: Get current version
        id: get_version
        run: |
          # Lese die erste Zeile, die typischerweise mit "## v" beginnt
          # Beispiel: "## v1.2.3 - 2025-01-21"
          CURRENT_VERSION="$(grep -m1 '^## v' VERSIONS.md | sed -E 's/^## v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')"
          
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Konnte keine Version in VERSIONS.md finden - ggf. Default auf 0.0.0"
            CURRENT_VERSION="0.0.0"
          fi

          echo "Aktuelle Version ist: $CURRENT_VERSION"
          echo "::set-output name=current_version::$CURRENT_VERSION"

      - name: Determine new version
        id: determine_new_version
        run: |
          # Hier sammeln wir alle Commit Messages aus dem aktuellen Push
          # GITHUB_SHA = letzter Commit, GITHUB_REF = Branch-Name
          # Tipp: Um wirklich nur die "neuen" Commits zu bekommen, kann man den Merge-Commit-Bereich prüfen.
          # Für ein Minimalbeispiel nehmen wir hier einfach alle Commits zwischen HEAD und HEAD~... 
          COMMITS="$(git log --pretty=format:%B ${{ github.event.before }}..${{ github.event.after }})"
          echo "Commit Messages:"
          echo "$COMMITS"

          CURRENT_VERSION="${{ steps.get_version.outputs.current_version }}"
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)

          # Prüfe, ob in den Commits das Tag <major_release></major_release> vorkommt
          if echo "$COMMITS" | grep -q "<major_release></major_release>"; then
            # Major-Version erhöhen
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            RELEASE_TYPE="(MAJOR)"
          else
            # Patch-Version erhöhen (kannst du natürlich auf MINOR-Logik erweitern)
            PATCH=$((PATCH + 1))
            RELEASE_TYPE="(PATCH)"
          fi

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "Neue Version: $NEW_VERSION $RELEASE_TYPE"
          echo "::set-output name=new_version::$NEW_VERSION"
          
          # Alle Commit Messages als Release Notes sammeln
          # (Alternativ könntest du hier filtern, oder nur Nachrichten ab dem letzten Tag, etc.)
          echo "::set-output name=release_notes::$COMMITS"

      - name: Update VERSIONS.md
        run: |
          NEW_VERSION="${{ steps.determine_new_version.outputs.new_version }}"
          RELEASE_NOTES="${{ steps.determine_new_version.outputs.release_notes }}"
          DATE="$(date +'%Y-%m-%d')"

          # Schreibe den neuen Block an den Anfang von VERSIONS.md
          # Format:
          # ## v<new_version> - 2025-01-21
          # - commit 1
          # - commit 2
          # ...
          {
            echo "## v${NEW_VERSION} - ${DATE}"
            echo ""
            while IFS= read -r line; do
              echo "- $line"
            done <<< "$RELEASE_NOTES"
            echo ""
          } > NEW_VERSIONS.md

          cat VERSIONS.md >> NEW_VERSIONS.md
          mv NEW_VERSIONS.md VERSIONS.md

          echo "VERSIONS.md aktualisiert:"
          head -n 20 VERSIONS.md

      - name: (Optional) Update README.md
        run: |
          NEW_VERSION="${{ steps.determine_new_version.outputs.new_version }}"

          # Beispiel: Ersetze in README.md einen Platzhalter VERSION_PLACEHOLDER durch neue Version
          # Oder aktualisiere eine Badge etc.
          sed -i "s/VERSION_PLACEHOLDER/${NEW_VERSION}/g" README.md || true

          echo "README.md aktualisiert (falls Platzhalter gefunden)."

      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add VERSIONS.md README.md
          git commit -m "chore: bump version to ${{ steps.determine_new_version.outputs.new_version }}"
          git push origin HEAD:${{ github.ref }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
